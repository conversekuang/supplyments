

##### 场景：

许多的系统原型原来是这样的，正常访问是没有问题的。但是缺点是用户太少：那么运营拉流量。一个DB服务器，一个web服务器。

<img src = "https://static001.geekbang.org/resource/image/83/6a/838911dd61e5a61408c3bf96871b846a.jpg" style="zoom:30%"></img>

##### 现象：

用户量提升，**系统的访问速度开始变慢**。

##### 分析对象：

程序的日志【如何分析程序日志得到原因？】

##### 原因：

系统慢的原因出现在和数据库的交互上。

因为你们数据库的调用方式是

1. 先获取数据库的连接，

2. 然后依靠这条连接从数据库中查询数据，

3. 最后关闭连接释放数据库资源。

   这种调用方式下，每次执行 SQL 都需要重新建立连接，所以你怀疑，是不是频繁地建立数据库连接耗费时间长导致了访问慢的问题



> 那么为什么频繁创建连接会造成响应时间慢呢？

我用"tcpdump -i bond0 -nn -tttt port 4490"命令抓取了线上 MySQL 建立连接的网络包来做分析，从抓包结果来看，整个 MySQL 的连接过程可以分为两部分：

1. TCP建立连接。
2. MySQL 服务端校验客户端密码的过程。【耗时4ms】

单条SQL语句执行的时间。【耗时1ms】



因此采用每次查询再关闭连接的方式。1s大概传输次数：1 / 5ms = 200 次



##### 解决方案：

​	采用池化技术。

​			1/1ms = 1000 次

也就是忽略了建立连接的时间，只需要考虑执行时间，因此提升数据库的查询效率。



连接池有很多，包括：数据库连接池、HTTP 连接池、Redis 连接池等等



<font color="red">**数据库连接池有两个最重要的配置：**最小连接数和最大连接数**。**</font>

对于数据库连接池，根据我的经验，一般在线上我建议最小连接数控制在 10 左右，最大连接数控制在 20～30 左右即可。

```
如果当前连接数小于最小连接数，则创建新的连接处理数据库请求；
如果连接池中有空闲连接则复用空闲连接；
如果空闲池中没有连接并且当前连接数小于最大连接数，则创建新的连接处理请求；
如果当前连接数已经大于等于最大连接数，则按照配置中设定的时间（C3P0 的连接池配置是 checkoutTimeout）等待旧的连接可用；
如果等待超过了这个设定时间则向用户抛出错误。
```



连接的维护问题：

正常的连接池可能存在故障：

- MySQL数据库域名对应的IP发生变化，池子中连接还是旧IP，所以当旧的关闭，导致不可用。【连接池中的IP没那么快变过来，导致服务提前关闭，连接不可用】

- MySQL中有“WAIT_Timeout”参数控制着当数据库连接闲置多长时间后，数据库会主动地关闭这条连接。【放着不用过期了，不能用了】

  

连接池中解决连接不可用：

1. **启动一个线程来定期检测连接池中的连接是否可用**，比如使用连接发送“select 1”的命令给数据库看是否会抛出异常，如果抛出异常则将这个连接从连接池中移除，并且尝试关闭。目前 C3P0 连接池可以采用这种方式来检测连接是否可用，也是我比较推荐的方式。
2. **在获取到连接之后，先校验连接是否可用，如果可用才会执行 SQL 语句**。比如 DBCP 连接池的 testOnBorrow 配置项，就是控制是否开启这个验证。这种方式在获取连接时会引入多余的开销，在线上系统中还是尽量不要开启，在测试服务上可以使用。



---

**需求升级**：

在一个接口里需要访问3次数据库。



**解决思路**：

可以通过多线程与数据库交互，能够加快速度。但是频繁创建线程开销很大，所以建立线程池。

```
如果线程池中的线程数少于 coreThreadCount 时，处理新的任务时会创建新的线程；
如果线程数大于 coreThreadCount 则把任务丢到一个队列里面，由当前空闲的线程执行；
当队列中的任务堆积满了的时候，则继续创建线程，直到达到 maxThreadCount；
当线程数达到 maxTheadCount 时还有新的任务提交，那么我们就不得不将它们丢弃了。
```



1. 线程池

- JDK实现的线程池：

  JDK 实现的这个线程池优先把任务放入队列暂存起来，而不是创建更多的线程，它比较适用于执行 CPU 密集型的任务，也就是需要执行大量 CPU 运算的任务。



- Tomcat实现的线程池：

Tomcat 使用的线程池就不是 JDK 原生的线程池，而是做了一些改造，当线程数超过 coreThreadCount 之后会优先创建线程，直到线程数到达



2. <font color="red">**线程池中使用的队列的堆积量也是我们需要监控的重要指标，对于实时性要求比较高的任务来说，这个指标尤为关键**</font>：

3. <font color="red">**线程池不使用无界队列**</font>：

​	也许你会觉得使用了无界队列后，任务就永远不会被丢弃，只要任务对实时性要求不高，反正早晚有消费完的一天。

​	但是，大量的任务堆积会占用大量的内存空间，一旦内存空间被占满就会频繁地触发 Full GC，造成服务不可用，我之前排查过的一次 GC 引起的宕机，起因就是系统中的一个线程池使用了无界队列。



---



池化技术：

1. 以空间换时间的方法。
2. 减少频繁的创建和销毁对象。
3. 可以对池内对象进行管理



缺点：

1. 消耗内存
2. 如果池内的对象使用不频繁，那么造成内存浪费
3. 池内对象需要系统初始就进行创建，增加启动时间



注意点：

1. 池子的最大值和最小值的设置很重要，初期可以依据经验来设置，后面还是需要根据实际运行情况做调整。

2. 池子中的对象需要在使用之前预先初始化完成，这叫做**池子的预热**
3. 关注空间占用避免出现空间过度使用出现内存泄露或者频繁垃圾回收等问题



